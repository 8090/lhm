#!/usr/bin/env ruby

require "trollop"
require "open3"
require "active_record"
require "tempfile"
require "benchmark"

ENV["PATH"] = File.expand_path(File.dirname(__FILE__)) + ":" + ENV["PATH"]

class Fuzz
  attr_accessor :opts, :processes, :initial, :changed

  def initialize(options = nil)
    self.opts = options || Trollop::options do
      opt :database,  "The database", :default => "large_hadron_migrator"
      opt :username,  "The username", :default => ""
      opt :host,      "The hostname", :default => "localhost", :short => "n"
      opt :password,  "The password", :type => :string
      opt :adapter,   "The adapter",  :default => "mysql"
      opt :processes, "Number of load processes", :default => 2
      opt :debug,     "Debug output", :default => false
    end
    self.opts[:processes] ||= 2

    self.processes = []
    self.initial = Hash.new(0)
    self.changed = Hash.new(0)
  end

  def debug?
    self.opts[:debug] == true
  end

  def run
    puts "Finished prefill in #{"%.6f" % Benchmark.measure { prefill }.real} seconds."
    fuzz
    puts "Finished migration in #{"%.6f" % Benchmark.measure { migrate }.real} seconds."
    unfuzz

    if debug?
      puts "initial: #{initial.inspect}"
      puts "changed: #{changed.inspect}"
    end
  end

  def prefill
    cmd = "prefill -d %{database} -n %{host}" % self.opts
    cmd += " -u %{username}" % self.opts unless self.opts[:username].empty?
    cmd += " -p %{password}" % self.opts if self.opts[:password]

    self.initial = parse(execute(cmd))
  end

  def fuzz
    opts[:processes].times do
      ["load", "load --slowdown=1"].each do |command|
        self.processes << popen3(command)
      end
    end
  end

  def migrate
  end

  def unfuzz
    self.processes.each do |stdin, stdout, stderr, thread|
      begin
        Process.kill("TERM", thread.pid)
        output = stdout.read.chomp
        puts output if debug?
        parse(output).each do |key, count|
          self.changed[key] = (self.changed[key] || 0) + count
        end
      rescue => error
        puts "#{error.class}: #{error.message}"
        puts stdout.readlines.inspect
      ensure
        stdin.close
        stdout.close
        stderr.close
      end
    end
  end

  private

  def execute(cmd)
    out, err, status = Open3.capture3(cmd)

    unless status.success?
      $stderr.puts "Could not run '#{ cmd }'"
      $stderr.puts err

      exit 1
    end

    return out
  end

  def popen3(cmd)
    Open3.popen3(cmd)
  end

  def parse(string)
    string.scan(/:([a-z]+=>\d+)/).inject({}) do |memo, match|
      key, value = match.first.split("=>")
      memo.merge(key.to_sym => value.to_i)
    end
  end
end

if $0 == __FILE__
  fuzz = Fuzz.new
  fuzz.run

  exit 0 # script aborts on errors
end
